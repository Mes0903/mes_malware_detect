/**
 * @file file_handler.cpp
 * @author Mes (mes900903@gmail.com) (Discord: Mes#0903)
 * @brief Load the file and store weights to file, any functions related to file operations should be here.
 * @version 0.1
 * @date 2022-12-15
 */

#include "file_handler.h"
#include "normalize.h"
#include "feature_num.h"
#include "Eigen/Eigen"

#include <set>
#include <filesystem>
#include <string>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <unordered_set>

#if __cplusplus >= 202002L
#include <string_view>
#include <ranges>
#else
#include <type_traits>
#endif

namespace LoadMatrix {
  namespace fs = std::filesystem;

  /**
   * @brief Read the data from the filepath to the matrix.
   *
   * @param filepath The file which would be loaded to matrix.
   * @return Eigen::MatrixXd The matrix which have completed loading.
   */
  std::pair<Eigen::MatrixXd, Eigen::MatrixXd> readDataSet(const fs::path &dirpath, const std::string &type, const int filenum)
  {
    std::vector<std::string> opcode_set;
    opcode_set.reserve(FEATURE_NUM);

    std::string line, opcode;
    std::stringstream ss;
    int opcode_num;
    {
      std::ifstream infile(dirpath / "token_sum" / "10.txt");
      if (infile.fail()) {
        std::cerr << "cant found " << (dirpath / "token_sum" / "10.txt").string() << '\n';
        std::cin.get();
        exit(1);
      }

      for (int i = 0; i < FEATURE_NUM; ++i) {
        std::getline(infile, line);
        ss << line;
        ss >> opcode >> opcode_num;
        opcode_set.push_back(std::move(opcode));
        ss.str("");
        ss.clear();
      }
    }
    int file_cnt = 0;
    Eigen::MatrixXd X = Eigen::MatrixXd::Zero(filenum, FEATURE_NUM);
    Eigen::MatrixXd Y = Eigen::MatrixXd::Zero(filenum, CLASS_NUM);

    using d_itr = fs::directory_iterator;
    for (const auto &tf : d_itr{ dirpath / (type + "ing_token") }) {
      std::ifstream infile(tf.path());
      while (std::getline(infile, line)) {
        ss << line;
        ss >> opcode >> opcode_num;

        if (opcode == "CLASS") {
          for (int i = 0; i < CLASS_NUM; ++i) {
            if (i == opcode_num - 1)
              Y(file_cnt, opcode_num - 1) = 1;
          }
        }
        else {
          auto itr = std::find(opcode_set.begin(), opcode_set.end(), opcode);
          if (itr != opcode_set.end()) {
            int index = std::distance(opcode_set.begin(), itr);
            X(file_cnt, index) = opcode_num;
          }
        }
        ss.str("");
        ss.clear();
      }
      ++file_cnt;
    }


    return { X, Y };
  };
}    // namespace LoadMatrix


namespace FileHandler {

  /**
   * @brief Return the project directory path.
   *
   * @return std::string The project directory path
   */
  std::string get_filepath()
  {
    namespace fs = std::filesystem;

    fs::path current = fs::current_path();

    while (current.filename().string() != "mes_malware_detect")
      current = current.parent_path();

    return current.string();
  }
}    // namespace FileHandler