#include <set>
#include <algorithm>
#include <array>
#include <random>
#include <vector>
#include <string>
#include <utility>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <unordered_map>
#include <sstream>

namespace fs = std::filesystem;

constexpr int FEATURE_NUM = 350;
const fs::path top(fs::current_path().parent_path());
const fs::path files(top / "files");

void tokenize(std::string type)
{
  fs::path token_folder = files / "token" / type;
  fs::path disasm_folder = files / (type + "_ida");

  std::stringstream ss;
  std::string line, addr, key;

  using d_itr = fs::directory_iterator;
  for (const auto &bf : d_itr{ disasm_folder }) {
    std::map<std::string, int> token;
    std::ifstream infile(bf.path());

    while (std::getline(infile, line)) {
      ss << line;
      ss >> addr;

      while (ss >> key) {
        if (key.find_first_of(";") != std::string::npos) {
          break;
        }
        else if (!(key.find_first_of("/[]()*&^%$#!~\'\\|-;\"<>{}.@?=:_ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890") != std::string::npos) && key.size() > 1) {
          if (token.find(key) != token.end())
            ++token[key];
          else
            token[key] = 1;

          break;
        }
      }

      ss.str("");
      ss.clear();
    }

    std::vector<std::pair<std::string, int>> output;
    for (const auto &[opcode, cnt] : token)
      output.emplace_back(opcode, cnt);

    std::sort(output.begin(), output.end(), [](std::pair<std::string, int> &l, std::pair<std::string, int> &r) { return l.second > r.second; });
    std::ofstream outfile(token_folder / bf.path().filename());
    for (const auto &[opcode, cnt] : output)
      outfile << opcode << " " << cnt << '\n';
  }
}

void add_label()
{
  std::stringstream ss;
  std::string line, filename;
  int label;
  std::map<std::string, int> label_list;
  {
    std::ifstream infile(files / "token" / "trainLabels.csv");
    while (std::getline(infile, line)) {
      ss << line;
      ss >> filename >> label;
      label_list[filename] = label;
      ss.str("");
      ss.clear();
    }
  }

  {
    fs::path token_folder = files / "token" / "train";
    using d_itr = fs::directory_iterator;
    for (const auto &tf : d_itr{ token_folder }) {
      label = label_list[tf.path().stem().string()];
      std::ofstream outfile(token_folder / tf.path().filename(), std::ios_base::app);
      outfile << "CLASS " << label;
    }
  }
}

void make_ds()
{
  std::stringstream ss;
  std::string line, filename;
  int label;
  std::map<std::string, int> label_list;
  {
    std::ifstream infile(files / "token" / "trainLabels.csv");
    while (std::getline(infile, line)) {
      ss << line;
      ss >> filename >> label;
      label_list[filename] = label;
      ss.str("");
      ss.clear();
    }
  }

  std::vector<std::vector<std::string>> total_list(9);
  for (const auto &[filename, CLASS] : label_list)
    total_list[CLASS - 1].push_back(filename);

  std::map<std::string, int> divide_list;
  for (int CLASS = 1; CLASS < 10; ++CLASS) {
    for (int i = 0; i < total_list[CLASS - 1].size(); ++i) {
      if (i < total_list[CLASS - 1].size() / 2)
        divide_list[total_list[CLASS - 1][i]] = 0;
      else
        divide_list[total_list[CLASS - 1][i]] = 1;
    }
  }

  fs::path token_folder = files / "token" / "train";
  fs::path train_folder = files / "training_token";
  fs::path test_folder = files / "testing_token";
  using d_itr = fs::directory_iterator;
  for (const auto &tf : d_itr{ token_folder }) {
    if (divide_list[tf.path().stem().string()] == 0)
      fs::copy(tf, train_folder / tf.path().filename());
    else
      fs::copy(tf, test_folder / tf.path().filename());
  }
}

void sum_token()
{
  std::vector<std::map<std::string, int>> total_list(10);
  std::stringstream ss;
  std::string line, opcode;
  int count;

  {
    using d_itr = fs::directory_iterator;
    fs::path train_folder = files / "training_token";
    for (const auto &tf : d_itr{ train_folder }) {
      std::map<std::string, int> single_file_list;
      std::ifstream infile(tf.path());
      while (std::getline(infile, line)) {
        ss << line;
        ss >> opcode >> count;
        if (opcode != "CLASS") {
          single_file_list[opcode] = count;
        }
        else {
          auto &tmap = total_list[count - 1];
          auto &total_map = total_list[9];
          for (const auto &opcode : single_file_list) {
            if (tmap.find(opcode.first) != tmap.end())
              tmap[opcode.first] += opcode.second;
            else
              tmap[opcode.first] = opcode.second;

            if (total_map.find(opcode.first) != total_map.end())
              total_map[opcode.first] += opcode.second;
            else
              total_map[opcode.first] = opcode.second;
          }
        }

        ss.str("");
        ss.clear();
      }
    }
  }

  fs::path sum_folder = files / "token_sum";
  for (int i = 0; i < 10; ++i) {
    std::vector<std::pair<std::string, int>> output;
    for (const auto &[opcode, cnt] : total_list[i])
      output.emplace_back(opcode, cnt);
    std::sort(output.begin(), output.end(), [](std::pair<std::string, int> &l, std::pair<std::string, int> &r) { return l.second > r.second; });

    std::ofstream outfile(sum_folder / (std::to_string(i + 1) + ".txt"));
    for (const auto &[opcode, cnt] : output)
      outfile << opcode << " " << cnt << '\n';
  }
}

int main()
{
  sum_token();
}
