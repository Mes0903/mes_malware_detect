#include <algorithm>
#include <random>
#include <vector>
#include <string>
#include <utility>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <unordered_map>
#include <sstream>

namespace fs = std::filesystem;

constexpr int FEATURE_NUM = 350;
const fs::path top(fs::current_path().parent_path());
const fs::path files(fs::current_path().parent_path() / "files");

void tokenize(std::string type)
{
  fs::path token_folder = files / "token" / type;
  fs::path objdump_folder = files / (type + "_token");

  std::stringstream ss;
  std::string line, addr, opcode, remain;

  using d_itr = fs::directory_iterator;
  for (const auto &bf : d_itr{ objdump_folder }) {
    std::map<std::string, int> token;
    std::ifstream infile(bf.path());

    int lcnt = 0;
    while (std::getline(infile, line)) {
      if (lcnt >= 8) {
        ss << line;
        ss >> addr >> opcode >> remain;

        if (addr != "" && addr != "..." && remain != "section" &&
            opcode.find('(') == std::string::npos &&
            opcode.find('<') == std::string::npos &&
            opcode.find('.') == std::string::npos) {
          if (token.find(opcode) != token.end())
            ++token[opcode];
          else
            token[opcode] = 1;
        }

        ss.str("");
        ss.clear();
      }

      ++lcnt;
    }

    std::ofstream outfile(token_folder / bf.path().filename());
    for (const auto &[opcode, cnt] : token)
      outfile << opcode << " " << cnt << '\n';
  }
}

// type: malware or benign
// mode: testing or training
void make_feature(std::string type, std::string mode)
{
  std::stringstream ss;
  std::string line, opcode;
  double feature_buf;

  std::map<std::string, double> total_feature;
  {
    std::ifstream infile(files / "token_sum" / "training" / "malware" / "malware_sum.txt");
    std::getline(infile, line);

    for (int i = 0; i < FEATURE_NUM; ++i) {
      std::getline(infile, line);
      ss << line;
      ss >> opcode >> feature_buf;

      total_feature[opcode] = feature_buf;

      ss.str("");
      ss.clear();
    }
  }

  std::ofstream feature_file;
  if (fs::exists(top / "include" / "dataset" / (mode + "_feature.txt")))
    feature_file.open(top / "include" / "dataset" / (mode + "_feature.txt"), std::ios::app);
  else
    feature_file.open(top / "include" / "dataset" / (mode + "_feature.txt"));

  std::ofstream label_file;
  if (fs::exists(top / "include" / "dataset" / (mode + "_label.txt")))
    label_file.open(top / "include" / "dataset" / (mode + "_label.txt"), std::ios::app);
  else
    label_file.open(top / "include" / "dataset" / (mode + "_label.txt"));

  using d_itr = fs::directory_iterator;
  for (const auto &bf : d_itr{ files / (mode + "_token") / type }) {
    std::map<std::string, double> single_feature;
    for (const auto &[k, v] : total_feature)
      single_feature[k] = 0;

    std::ifstream infile(bf.path());
    while (std::getline(infile, line)) {
      ss << line;
      ss >> opcode >> feature_buf;

      if (total_feature.find(opcode) != total_feature.end())
        single_feature[opcode] = feature_buf;

      ss.str("");
      ss.clear();
    }

    for (const auto &[o_opcode, o_num] : single_feature)
      feature_file << o_num << ' ';

    feature_file << '\n';

    if (type == "malware")
      label_file << 1 << '\n';
    else
      label_file << 0 << '\n';
  }
}

void sum_token(std::string type, std::string mode, int num)
{
  std::map<std::string, int> token;
  std::stringstream ss;
  std::string line, opcode;
  int ocnt{};

  using d_itr = fs::directory_iterator;
  for (const auto &tf : d_itr{ files / (mode + "_token") / type }) {
    std::ifstream infile(tf.path());

    while (std::getline(infile, line)) {
      ss << line;
      ss >> opcode >> ocnt;

      if (opcode != "") {
        if (token.find(opcode) != token.end())
          token[opcode] += ocnt;
        else
          token[opcode] = ocnt;
      }

      ss.str("");
      ss.clear();
    }
  }

  std::vector<std::pair<int, std::string>> output;
  for (const auto &[opcode, cnt] : token)
    output.emplace_back(cnt, opcode);

  std::sort(output.begin(), output.end(), [](std::pair<int, std::string> &l, std::pair<int, std::string> &r) { return l.first > r.first; });

  std::ofstream outfile(files / "token_sum" / mode / type / (type + "_sum.txt"));
  outfile << "sample nums: " << num << '\n';
  for (const auto &[cnt, opcode] : output)
    outfile << opcode << " " << static_cast<double>(cnt) / num << '\n';
}

void make_ds(std::string type)
{
  int tfcnt{}, test_num{}, train_num{};
  std::string mode;
  // path() is whole path; path().filename() is file name;
  using d_itr = fs::directory_iterator;

  // type: malware or benign
  // mode: testing or training
  for (const auto &tf : d_itr{ files / type }) {
    std::string target = tf.path().filename();
    if (auto p = target.find(".exe"); p != std::string::npos)
      target = target.substr(0, p);
    else {
      std::cout << "non valid file " << target << '\n';
      continue;
    }

    if (fs::file_size(files / "token" / type / (target + ".txt")) == 0) {
      std::cout << "the size of " << target << " is 0, wont be counted\n";
      continue;
    }

    if (tfcnt % 2) {
      mode = "testing";
      ++test_num;
    }
    else {
      mode = "training";
      ++train_num;
    }

    if (!fs::exists(files / (mode + "_pe") / type / (target + ".exe")))
      fs::copy(tf.path(), files / (mode + "_pe") / type / (target + ".exe"));    // copy pe

    if (fs::exists(files / (mode + "_token") / type / (target + ".txt")))
      fs::remove(files / (mode + "_token") / type / (target + ".txt"));

    fs::copy(files / "token" / type / (target + ".txt"), files / (mode + "_token") / type / (target + ".txt"));    // copy token

    ++tfcnt;
  }

  std::cout << "tfcnt of " << type << " is " << tfcnt << '\n';
  std::cout << "sum " << type << " testing token...\n";
  sum_token(type, "testing", test_num);
  std::cout << "sum " << type << " training token...\n";
  sum_token(type, "training", train_num);
  std::cout << "making " << type << " testing feature...\n";
  make_feature(type, "testing");
  std::cout << "making " << type << " training feature...\n";
  make_feature(type, "training");
}

int main()
{
  std::cout << "removing files...\n";
  fs::remove_all(top / "include" / "dataset");
  fs::create_directory(top / "include" / "dataset");

  fs::remove_all(files / "testing_pe");
  fs::create_directory(files / "testing_pe");
  fs::create_directory(files / "testing_pe" / "benign");
  fs::create_directory(files / "testing_pe" / "malware");

  fs::remove_all(files / "testing_token");
  fs::create_directory(files / "testing_token");
  fs::create_directory(files / "testing_token" / "benign");
  fs::create_directory(files / "testing_token" / "malware");

  fs::remove_all(files / "training_pe");
  fs::create_directory(files / "training_pe");
  fs::create_directory(files / "training_pe" / "benign");
  fs::create_directory(files / "training_pe" / "malware");

  fs::remove_all(files / "training_token");
  fs::create_directory(files / "training_token");
  fs::create_directory(files / "training_token" / "benign");
  fs::create_directory(files / "training_token" / "malware");

  // std::cout << "tokenize benign-ware...\n";
  // tokenize("benign");
  // std::cout << "tokenize malware...\n";
  // tokenize("malware");

  std::cout << "transforming benign-ware...\n";
  make_ds("benign");
  std::cout << "transforming malware...\n";
  make_ds("malware");
}