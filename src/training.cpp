/**
 * @file training_ball.cpp
 * @author Mes
 * @brief Traning the Adaboost to classified if an object is an ball, then stored the weighting.
 *        Execute it by command `rosrun mes_detect_ball Training_Ball` if you use ROS to build it.
 * @version 0.1
 * @date 2022-11-17
 */

#include "adaboost.h"
#include "logistic.h"
#include "make_feature.h"
#include "segment.h"
#include "normalize.h"
#include "file_handler.h"
#include "metric.h"

#include <iostream>
#include <Eigen/Dense>
#include <limits>
#include <filesystem>

int main()
{
  //const std::string filepath = File_handler::get_filepath(argv[0]);
  namespace fs = std::filesystem;

  const std::string filepath = fs::current_path().parent_path().string();

  int case_num = 0;
  int sample = 0;

  std::cout << "Input 1 if training, others if loading\n>";
  std::cin >> case_num;

  if (case_num == 1) {
    std::cout << "input sample numbers\n>";
    std::cin >> sample;
  }
  std::cin.clear();
  std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

  /* fitting */
  puts("read training data...");
  Eigen::MatrixXd train_feature = Load_Matrix::readDataSet(filepath + "/include/dataset/training_feature2.txt", 4624, FEATURE_NUM);    // file, row, col

  puts("reading training label...");
  Eigen::VectorXd train_label = Load_Matrix::readLabel(filepath + "/include/dataset/training_label2.txt", 4624);    // file, segment num(row)

  puts("reading testing data...");
  Eigen::MatrixXd test_feature1 = Load_Matrix::readDataSet(filepath + "/include/dataset/testing_feature.txt", 4622, FEATURE_NUM);
  Eigen::MatrixXd test_feature2 = Load_Matrix::readDataSet(filepath + "/include/dataset/testing_feature2.txt", 4622, FEATURE_NUM);
  Eigen::MatrixXd test_feature3 = Load_Matrix::readDataSet(filepath + "/include/dataset/testing_feature3.txt", 4622, FEATURE_NUM);
  Eigen::MatrixXd test_feature4 = Load_Matrix::readDataSet(filepath + "/include/dataset/testing_feature4.txt", 4622, FEATURE_NUM);
  Eigen::MatrixXd test_feature5 = Load_Matrix::readDataSet(filepath + "/include/dataset/testing_feature5.txt", 4622, FEATURE_NUM);
  Eigen::MatrixXd test_feature6 = Load_Matrix::readDataSet(filepath + "/include/dataset/training_feature2.txt", 4622, FEATURE_NUM);

  puts("reading testing label...");
  const Eigen::VectorXd test_label1 = Load_Matrix::readLabel(filepath + "/include/dataset/testing_label.txt", 4622);
  const Eigen::VectorXd test_label2 = Load_Matrix::readLabel(filepath + "/include/dataset/testing_label2.txt", 4622);
  const Eigen::VectorXd test_label3 = Load_Matrix::readLabel(filepath + "/include/dataset/testing_label3.txt", 4622);
  const Eigen::VectorXd test_label4 = Load_Matrix::readLabel(filepath + "/include/dataset/testing_label4.txt", 4622);
  const Eigen::VectorXd test_label5 = Load_Matrix::readLabel(filepath + "/include/dataset/testing_label5.txt", 4622);
  const Eigen::VectorXd test_label6 = Load_Matrix::readLabel(filepath + "/include/dataset/training_label2.txt", 4622);

  if (case_num == 1) {
    Normalizer normalizer;
    puts("Normalize");
    normalizer.fit(train_feature);
    //train_feature = normalizer.transform(train_feature);
    //test_feature1 = normalizer.transform(test_feature1);
    //test_feature2 = normalizer.transform(test_feature2);
    //test_feature3 = normalizer.transform(test_feature3);
    //test_feature4 = normalizer.transform(test_feature4);
    //test_feature5 = normalizer.transform(test_feature5);
    //test_feature6 = normalizer.transform(test_feature6);

    for (int i = 0; i < sample; ++i) {
      std::cout << "training sample " << i + 1 << "...\n";
      puts("start tranning");
      Adaboost<logistic> A(100);
      A.fit(train_feature, train_label);

      // prediction
      puts("\nmake prediction");

      auto check = test_feature5;

      const Eigen::VectorXd pred_1 = A.predict(test_feature1);
      const Eigen::VectorXd pred_2 = A.predict(test_feature2);
      const Eigen::VectorXd pred_3 = A.predict(test_feature3);
      const Eigen::VectorXd pred_4 = A.predict(test_feature4);
      const Eigen::VectorXd pred_5 = A.predict(test_feature5);
      const Eigen::VectorXd pred_6 = A.predict(test_feature6);

      puts("cal confusion matrix");
      const Eigen::MatrixXd confusion_matrix2 = metric::cal_confusion_matrix(test_label2, pred_2);
      A.set_confusion_matrix(confusion_matrix2);
      A.print_confusion_matrix();

      std::cout << "addition data:\n";
      const Eigen::MatrixXd confusion_matrix1 = metric::cal_confusion_matrix(test_label1, pred_1);
      const Eigen::MatrixXd confusion_matrix3 = metric::cal_confusion_matrix(test_label3, pred_3);
      const Eigen::MatrixXd confusion_matrix4 = metric::cal_confusion_matrix(test_label4, pred_4);
      const Eigen::MatrixXd confusion_matrix5 = metric::cal_confusion_matrix(test_label5, pred_5);
      const Eigen::MatrixXd confusion_matrix6 = metric::cal_confusion_matrix(test_label6, pred_6);
      std::cout << confusion_matrix1 << "\n-----------\n"
                << confusion_matrix3 << "\n-----------\n"
                << confusion_matrix4 << "\n-----------\n"
                << confusion_matrix5 << "\n-----------\n"
                << confusion_matrix6 << "\n-----------\n";

      File_handler::store_weight(confusion_matrix2, filepath + "/include/weight_data/adaboost_weight.txt", A, normalizer);
    }
  }
  else {
    Normalizer normalizer;
    Adaboost<logistic> A;

    puts("Load Weighting...");
    File_handler::load_weight(filepath + "/include/weight_data/adaboost_weight.txt", A, normalizer);

    puts("Transforming test data...");
    //test_feature1 = normalizer.transform(test_feature1);
    //test_feature2 = normalizer.transform(test_feature2);
    //test_feature3 = normalizer.transform(test_feature3);
    //test_feature4 = normalizer.transform(test_feature4);
    //test_feature5 = normalizer.transform(test_feature5);
    //test_feature6 = normalizer.transform(test_feature6);

    puts("make prediction");
    const Eigen::VectorXd pred_1 = A.predict(test_feature1);
    const Eigen::VectorXd pred_2 = A.predict(test_feature2);
    const Eigen::VectorXd pred_3 = A.predict(test_feature3);
    const Eigen::VectorXd pred_4 = A.predict(test_feature4);
    const Eigen::VectorXd pred_5 = A.predict(test_feature5);
    const Eigen::VectorXd pred_6 = A.predict(test_feature6);

    puts("cal confusion matrix");
    Eigen::MatrixXd confusion_matrix2 = metric::cal_confusion_matrix(test_label2, pred_2);
    std::cout << confusion_matrix2 << "\n-----------\n";

    double TP = confusion_matrix2(0, 0), FP = confusion_matrix2(0, 1), FN = confusion_matrix2(1, 0), TN = confusion_matrix2(1, 1);
    double accuracy = static_cast<double>(TP + TN) / (TP + TN + FP + FN);
    double recall = static_cast<double>(TP) / (TP + FN);
    double precision = static_cast<double>(TP) / (TP + FP);
    double F1_Score = 2 * precision * recall / (precision + recall);

    std::cout << "addition data:\n";
    Eigen::MatrixXd confusion_matrix1 = metric::cal_confusion_matrix(test_label1, pred_1);
    Eigen::MatrixXd confusion_matrix3 = metric::cal_confusion_matrix(test_label3, pred_3);
    Eigen::MatrixXd confusion_matrix4 = metric::cal_confusion_matrix(test_label4, pred_4);
    Eigen::MatrixXd confusion_matrix5 = metric::cal_confusion_matrix(test_label5, pred_5);
    Eigen::MatrixXd confusion_matrix6 = metric::cal_confusion_matrix(test_label6, pred_6);
    std::cout << confusion_matrix1 << "\n-----------\n"
              << confusion_matrix3 << "\n-----------\n"
              << confusion_matrix4 << "\n-----------\n"
              << confusion_matrix5 << "\n-----------\n"
              << confusion_matrix6 << "\n-----------\n";

    std::cout << "Accuracy : " << accuracy << '\n'
              << "recall : " << recall << '\n'
              << "precision: " << precision << '\n'
              << "F1 Score: " << F1_Score << '\n';
  }
}